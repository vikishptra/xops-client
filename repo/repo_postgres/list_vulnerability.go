package postgres

import (
	"context"

	"gorm.io/gorm"

	"xops-admin/domain"
	domain_overview "xops-admin/domain/user/overview"
	"xops-admin/model"
)

type ListVulnerabilityRepo struct {
	db *gorm.DB
}

func NewListVulnerabilityRepo(db *gorm.DB) domain.ListVulnerabilityRepository {
	return &ListVulnerabilityRepo{db: db}
}

func (r *ListVulnerabilityRepo) Create(ctx context.Context, vuln *model.ListVulnerability) error {
	return r.db.WithContext(ctx).Create(vuln).Error
}

func (r *ListVulnerabilityRepo) GetByID(ctx context.Context, id int64) (*model.ListVulnerability, error) {
	var vuln model.ListVulnerability
	if err := r.db.WithContext(ctx).First(&vuln, id).Error; err != nil {
		return nil, err
	}
	return &vuln, nil
}

func (r *ListVulnerabilityRepo) Update(ctx context.Context, vuln *model.ListVulnerability) error {
	return r.db.WithContext(ctx).Save(vuln).Error
}

func (r *ListVulnerabilityRepo) Delete(ctx context.Context, id int64) error {
	return r.db.WithContext(ctx).Delete(&model.ListVulnerability{}, id).Error
}
func (r *ListVulnerabilityRepo) IsTypeBugExists(ctx context.Context, typeBug string) (bool, error) {
	var count int64
	if err := r.db.WithContext(ctx).
		Model(&model.TypeBug{}).
		Where("name = ?", typeBug).
		Count(&count).Error; err != nil {
		return false, err
	}
	return count > 0, nil
}

func (u *ListVulnerabilityRepo) List(ctx context.Context, cursorID, limit int, direction string) ([]model.ListVulnerability, bool, interface{}, interface{}, error) {
	var results []model.ListVulnerability
	var hasMore bool

	query := u.db.Order("unique_id ASC").Limit(limit + 1)

	if direction == "next" && cursorID > 0 {
		query = query.Where("unique_id > ?", cursorID)
	} else if direction == "prev" && cursorID > 0 {
		query = u.db.Order("unique_id DESC").Where("unique_id < ?", cursorID).Limit(limit + 1)
	}

	if err := query.Find(&results).Error; err != nil {
		return nil, false, nil, nil, err
	}

	if len(results) > limit {
		hasMore = true
		results = results[:limit]
	}

	var nextCursor, prevCursor interface{}
	if len(results) > 0 {
		nextCursor = results[len(results)-1].UniqueID
		prevCursor = results[0].UniqueID
	}

	// kalau direction prev, urutkan kembali ASC biar konsisten
	if direction == "prev" {
		for i, j := 0, len(results)-1; i < j; i, j = i+1, j-1 {
			results[i], results[j] = results[j], results[i]
		}
	}

	return results, hasMore, nextCursor, prevCursor, nil
}

func (u *ListVulnerabilityRepo) ListVulnerabilityNames(ctx context.Context, search string, page, limit int) ([]domain_overview.VulnerabilityItem, int64, error) {
	var (
		nameBugs []string
		total    int64
	)

	query := u.db.Model(&model.ListVulnerability{}).
		Select("name_bug").
		Order("name_bug ASC")

	// Search filter
	if search != "" {
		query = query.Where("name_bug ILIKE ?", "%"+search+"%")
	}

	// Hitung total data
	if err := query.Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Pagination (offset-limit)
	offset := (page - 1) * limit
	if err := query.Offset(offset).Limit(limit).Pluck("name_bug", &nameBugs).Error; err != nil {
		return nil, 0, err
	}

	// Convert ke struct
	result := make([]domain_overview.VulnerabilityItem, len(nameBugs))
	for i, nameBug := range nameBugs {
		result[i] = domain_overview.VulnerabilityItem{
			No:            offset + i + 1,
			Vulnerability: nameBug,
		}
	}

	return result, total, nil
}
